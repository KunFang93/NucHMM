import sys
import os.path
import subprocess
import numpy as np
from NucHMM_utilities import sort_chrom_coor1_coor2, bedops_map, boundary_check
from NucHMM_Load_Write_files import write_segment_file


def new_round(number):
    # default round function in python is tricky, use this round function
    return int(int(number * 1 + 0.5) / 1)


def create_state_coverage_files(genesfile, statefile, samplepoints, refgene, interval_other_area, up_boundary,
                       down_boundary, step1, step2):
    '''
    Create several files for calculating the coverage of the states. This function divides to two steps.
    step1 will use the genesfile and generate three files: upstream, genebody and downstream segment filtered file.
    step2 will use the three files generated by first step and use bedops software to assign state to each bins in those
    three files
    :param genesfile: gene set files. format "chrom start end strand name id", sep='\t'
    :param statefile: srt.uniq.states.bed format "chrom start end state"
    :param sample_rate:
    :param refgene:
    :param interval_other_area:
    :param up_boundary:
    :param down_boundary:
    :param step1: True/False. mark for running or not
    :param step2: True/False. mark for running or not
    :return: None
    '''
    genebody_segment = './genebody_seg.srt.bed'
    uprange = './TSS_up.bed'
    up_segment = './TSS_up_seg.srt.bed'
    upfilt_segment = './TSS_up_seg.srt.filt.bed'
    down_segment = './TTS_down_seg.srt.bed'
    downfilt_segment = './TTS_down_seg.srt.filt.bed'
    celltype = statefile.split('/')[-1].split('_')[0]
    mapped_genebed = './' + celltype + '_genebody_states.bed'
    mapped_upbed = './' + celltype + '_TSS_up_states.bed'
    mapped_downbed = './' + celltype + '_TTS_down_states.bed'
    if step1:
        print('Step1: Select and Segment upstream downstream and genebody region')
        body_file = {}
        up_region = {}
        down_region = {}
        with open(genesfile, 'r') as gene_file, open(uprange,'w') as up_range:
            count_read = 0
            for line in gene_file:
                count_read += 1
                sys.stdout.write('\rGene file line: ' + str(count_read))
                L = line.strip().split()
                L_chr = L[0]
                L_start = int(L[1])
                L_end = int(L[2])
                L_strand = L[3]
                L_name = L[4]
                '''genebody segment'''
                gene_length = L_end - L_start
                interval_length = gene_length / samplepoints
                if L_strand == "+":
                    for i in range(samplepoints):
                        tmp_start = L_start + new_round(i * interval_length)
                        tmp_end = L_start + new_round((i + 1) * interval_length)
                        if i == samplepoints - 1:
                            tmp_end = L_end
                        '''+ strand seg id from small to large'''
                        key_body = '_'.join([L_chr, str(tmp_start), str(tmp_end)])
                        out_line = [L_strand, L_name, str(i)]
                        body_file[key_body] = out_line
                else:
                    for i in range(samplepoints):
                        tmp_start = L_start + new_round(i * interval_length)
                        tmp_end = L_start + new_round((i + 1) * interval_length)
                        if i == samplepoints - 1:
                            tmp_end = L_end
                        '''- trand seg id from large to small'''
                        key_body = '_'.join([L_chr, str(tmp_start), str(tmp_end)])
                        out_line = [L_strand, L_name, str(samplepoints - i - 1)]
                        body_file[key_body] = out_line

                '''upstream segment and downstream segment'''
                if L_strand == '+':
                    upstartbound = boundary_check(L_start - up_boundary, L_chr, refgene)
                    upendbound = L_start
                    downstartbound = L_end
                    uprangeout = [L_chr, str(upstartbound), str(upendbound), L_strand, L_name]
                    up_range.write('\t'.join(uprangeout) + '\n')
                    for i in range(up_boundary // interval_other_area):
                        tmp_start2 = upstartbound + i * interval_other_area
                        tmp_end2 = upstartbound + (i + 1) * interval_other_area
                        key_up = '_'.join([L_chr, str(tmp_start2), str(tmp_end2)])
                        out_line2 = [ L_strand, L_name, str(i)]
                        up_region[key_up] = out_line2
                    for j in range(down_boundary // interval_other_area):
                        tmp_start3 = downstartbound + j * interval_other_area
                        tmp_end3 = boundary_check(downstartbound + (j + 1) * interval_other_area, L_chr, refgene)
                        key_down = '_'.join([L_chr, str(tmp_start3), str(tmp_end3)])
                        out_line3 = [L_strand, L_name, str(j)]
                        down_region[key_down] = out_line3
                else:
                    upstartbound = boundary_check(L_end + up_boundary, L_chr, refgene)
                    upendbound = L_end
                    downstartbound = L_start
                    uprangeout = [L_chr, str(upendbound), str(upstartbound), L_strand, L_name]
                    up_range.write('\t'.join(uprangeout) + '\n')
                    for i in range(up_boundary // interval_other_area):
                        tmp_start2 = upstartbound - (i + 1) * interval_other_area
                        tmp_end2 = upstartbound - i * interval_other_area
                        key_up = '_'.join([L_chr, str(tmp_start2), str(tmp_end2)])
                        out_line2 = [L_strand, L_name, str(i)]
                        up_region[key_up] = out_line2
                    for j in range(down_boundary // interval_other_area):
                        tmp_start3 = boundary_check(downstartbound - (j + 1) * interval_other_area, L_chr, refgene)
                        tmp_end3 = boundary_check(downstartbound - j * interval_other_area, L_chr, refgene)
                        key_down = '_'.join([L_chr, str(tmp_start3), str(tmp_end3)])
                        out_line3 = [L_strand, L_name, str(j)]
                        down_region[key_down] = out_line3

        gene_file.close()
        up_range.close()
        print('\n')
        print('Sorting gene body file...')
        sorted_gb_key = sort_chrom_coor1_coor2(body_file)
        write_segment_file(sorted_gb_key,body_file,genebody_segment)
        print('Sorting upstream region file...')
        sorted_up_key = sort_chrom_coor1_coor2(up_region)
        write_segment_file(sorted_up_key,up_region,up_segment)
        print('Sorting downstream region file...')
        sorted_down_key = sort_chrom_coor1_coor2(down_region)
        write_segment_file(sorted_down_key,down_region,down_segment)
        print('Filter out gene body part in TSS_up and gene body as well as TSS_up parts in TTS_down')
        print('TSS_up filtering')
        subprocess.call('bedtools intersect -wa -a ' + up_segment + ' -b ' + genesfile + ' -v > ' + upfilt_segment,
                        shell=True)
        print('TTS_down filtering')
        subprocess.call('bedtools intersect -wa -a ' + down_segment + ' -b ' + genesfile + ' ' + uprange + ' -v > ' +
                        downfilt_segment, shell=True)
        print('Filter step Finish!')
        subprocess.call('rm ' + up_segment, shell=True)
        subprocess.call('rm ' + down_segment, shell=True)

    if step2:
        print('\n')
        print('Step2')
        print("Pay attention to State.merged.srt.bed format, the State mark should in the 4th column.")
        print('mapped state')
        bedops_map(genebody_segment,statefile,mapped_genebed)
        bedops_map(upfilt_segment,statefile,mapped_upbed)
        bedops_map(downfilt_segment,statefile,mapped_downbed)

def file2dict(mappedfilelist, interval_other_area, samplepoints, up_boundary, down_boundary, background_state,
              states, totalgenenum):
    '''
    Transfer three mapped file to a dictionary contain the coverage information of all functional states
    :param mappedfilelist: a list includes:[mapped_upbed,mapped_genebed,mapped_downbed],
    mapped_files are generated by step2 in cal_state_coverage
    :param interval_other_area: equal to genebody_rescale_length//sample_rate e.g if gene body rescale to 10k and sample
    rate is 1 sample/ per 100bp, then interval for other area also be 10k/100 = 100
    :param sample_rate: 100 means 1 sample point / per 100 bp
    :param up_boundary: upper distance from TSS
    :param down_boundary: down distance from TTS
    :param background_state: a list includes the background states
    :param states: a list includes the functional states (not include background states)
    :param totalgenenum: total gene number in genebody_unique files
    :return: States_x is a dictionary which key is the states and value is a list that
    contain coverage count of the bins
    '''
    genebody_rescale_length = interval_other_area * samplepoints
    rescale_length = interval_other_area
    up_sample = up_boundary // interval_other_area
    down_sample = down_boundary // interval_other_area
    gb_sample = samplepoints
    diction_states = {i: {'TSS': {j: 0 for j in range(up_sample)}, 'genebody': {j: 0 for j in range(gb_sample)},
                          'TTS': {j: 0 for j in range(down_sample)}} for i in states}
    load_count = 0
    print('Transfering mapped files to dictionary...')
    for file in mappedfilelist:
        region = file.split('/')[-1].split('_')[1]
        with open(file, 'r') as input_file:
            for line in input_file:
                load_count += 1
                sys.stdout.write('\rLoading files: ' + str(load_count))
                L = line.strip().split()
                L_start = int(L[1])
                L_end = int(L[2])
                bin_length = L_end - L_start
                L_bin = int(L[5])
                try:
                    L_states = L[6].split(';')
                    for state in L_states:
                        if state in background_state:
                            continue
                        else:
                            diction_states[int(state)][region][L_bin] += 1.0 / bin_length * rescale_length
                except IndexError:
                    '''Some rows don't have column 7'''
                    continue
        input_file.close()
    print('\n')
    States_x = {state: [] for state in diction_states}
    State_total = np.zeros(up_sample+down_sample+gb_sample)
    for state in diction_states:
        #    plt.figure()
        for i in range(up_sample):
            States_x[state].append(diction_states[state]['TSS'][i])
        # avoid dramatically change between boundary


        for j in range(gb_sample):
            States_x[state].append(diction_states[state]['genebody'][j])
        for k in range(down_sample):
            States_x[state].append(diction_states[state]['TTS'][k])

        # normalize by total gene number
        States_x[state] = (np.array(States_x[state]) / totalgenenum * 100)
        State_total += States_x[state]
    
        # print(State_total)
    # switch to frequence
    for state in States_x:
        States_x[state] = States_x[state] / State_total * 100
    print('Transfering Finish!')
    return States_x
